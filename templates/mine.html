<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Minesweeper</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --cell-size: 30px;
            --retro-bg: #0d0d2e;
            --retro-accent: #ff9900;
            --retro-text: #00ccff;
            --retro-secondary: #ff33ff;
            --transition: all 0.2s ease;
        }
        
        body {
            font-family: 'Press Start 2P', cursive;
            background: var(--retro-bg);
            margin: 0; padding: 15px;
            display: flex; flex-direction: column; align-items: center;
            min-height: 100vh; color: var(--retro-text);
            overflow: hidden;
        }
        
        h1 {
            color: var(--retro-accent);
            text-shadow: 0 0 10px var(--retro-accent), 0 0 5px var(--retro-secondary);
            font-size: 2.2rem; letter-spacing: 2px;
            text-transform: uppercase; margin-bottom: 10px;
        }
        
        .header-bar {
            width: 100%; max-width: 600px;
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px;
        }
        .header-buttons { display: flex; gap: 10px; }
        .header-btn {
            background: rgba(0, 204, 255, 0.1); color: var(--retro-text);
            border: 1px solid var(--retro-text); padding: 8px 16px;
            border-radius: 20px; cursor: pointer; text-decoration: none;
            font-size: 0.8rem; transition: var(--transition);
        }
        .header-btn:hover { background: rgba(0, 204, 255, 0.2); transform: translateY(-2px); }

        .game-wrapper {
            background-color: #1a1a3a;
            padding: 15px; border: 4px solid;
            border-color: #555 #333 #333 #555; border-radius: 6px;
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.5); max-width: 100%;
        }
        
        .game-info {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px; margin-bottom: 10px; background-color: #000;
            border: 3px solid; border-color: #333 #555 #555 #333;
        }
        
        .mines-count, .timer {
            color: #ff4444; font-family: 'Courier New', Courier, monospace;
            font-size: 24px; padding: 5px 10px; min-width: 70px;
            text-shadow: 0 0 5px #ff4444; letter-spacing: 2px;
        }
        
        .reset-button {
            width: 36px; height: 36px; font-size: 20px; cursor: pointer;
            border: 3px solid; border-color: #555 #333 #333 #555;
            background-color: #444; display: flex; align-items: center; justify-content: center;
        }
        .reset-button:active { border-color: #333 #555 #555 #333; }
        
        .board { display: grid; border: 3px solid; border-color: #333 #555 #555 #333; }
        
        .cell {
            width: var(--cell-size); height: var(--cell-size);
            background-color: #444; border: 2px solid;
            border-color: #666 #333 #333 #666;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 18px; cursor: pointer; user-select: none;
            transition: background-color 0.1s;
        }
        .cell:active:not(.revealed) { border-color: #333; background-color: #3a3a3a; }
        .cell.revealed { border: 1px solid #333; background-color: #2a2a4a; cursor: default; }
        .cell.mine { background-color: #ff4444; animation: mineExplode 0.5s; }
        @keyframes mineExplode { 0% {transform: scale(0.5); border-radius: 50%;} 100% {transform: scale(1); border-radius: 0;} }
        
        .cell-1 { color: #00ccff; } .cell-2 { color: #4caf50; }
        .cell-3 { color: #ff4444; } .cell-4 { color: #cc00ff; }
        .cell-5 { color: #ff9900; } .cell-6 { color: #00ffff; }
        .cell-7 { color: #ffffff; } .cell-8 { color: #a0a0a0; }
        
        .difficulty { margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        
        button.diff-btn {
            background-color: transparent; color: var(--retro-text); border: 2px solid var(--retro-text);
            padding: 8px 15px; border-radius: 5px; cursor: pointer; transition: var(--transition);
            font-family: 'Press Start 2P', cursive;
        }
        button.diff-btn:hover, button.diff-btn.active { background-color: var(--retro-accent); color: var(--black); border-color: var(--retro-accent); }
        
        .flag-toggle { display: none; margin-bottom: 15px; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); z-index: 100; justify-content: center; align-items: center; animation: fadeIn 0.3s; }
        .modal-content { background-color: #0d0d2e; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 0 30px rgba(0, 204, 255, 0.8); max-width: 400px; width: 90%; border: 3px solid var(--retro-accent); animation: modalSlideIn 0.4s ease-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes modalSlideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal h2 { margin-top: 0; color: var(--retro-accent); font-size: 2rem; }
        .modal p { font-size: 1rem; }
        .modal button { background-color: var(--retro-accent); color: #000; border-radius: 5px; margin-top: 20px; }
        .modal button:hover { background-color: #ffbe4d; box-shadow: 0 0 15px var(--retro-accent); }

        @media (pointer: coarse), (max-width: 768px) {
            :root { --cell-size: 28px; }
            .flag-toggle { display: block; }
        }
        @media (max-width: 480px) {
            :root { --cell-size: 24px; }
            h1 { font-size: 1.8rem; }
        }
    </style>
</head>
<body>
    <h1>Minesweeper</h1>
    <div class="header-bar">
        <div class="header-buttons">
            <a href="/" class="header-btn">Back</a>
            <button id="newGameBtn" class="header-btn">New Game</button>
            <button id="instructionsBtn" class="header-btn">Help</button>
        </div>
    </div>
    <div class="difficulty">
        <button id="easyBtn" class="diff-btn">Easy</button>
        <button id="mediumBtn" class="diff-btn active">Medium</button>
        <button id="hardBtn" class="diff-btn">Hard</button>
    </div>
    <button id="flagToggleBtn" class="diff-btn flag-toggle">ðŸš© Flag Mode</button>
    <div class="game-wrapper">
        <div class="game-info">
            <div id="mines-count" class="mines-count">000</div>
            <div id="reset-button" class="reset-button">ðŸ˜Š</div>
            <div id="timer" class="timer">000</div>
        </div>
        <div id="board" class="board"></div>
    </div>
    
    <div id="result-modal" class="modal">
        <div class="modal-content">
            <h2 id="result-title">You Win!</h2>
            <p id="result-message">Time: 0 seconds</p>
            <button id="play-again-btn">Play Again</button>
        </div>
    </div>
    <div id="instructions-modal" class="modal">
        <div class="modal-content">
            <h2>How to Play</h2>
            <p>Click a cell to reveal it. A number shows how many mines are adjacent. Avoid the mines!</p>
            <p>**Desktop**: Right-click to place a flag.</p>
            <p>**Mobile**: Tap the "Flag Mode" button, then tap a cell to place/remove a flag.</p>
            <button id="close-instructions-btn">Close</button>
        </div>
    </div>

    <script>
        // State
        let state = {};
        const difficulties = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 16, cols: 16, mines: 40 },
            hard: { rows: 16, cols: 30, mines: 99 }
        };

        // DOM Elements
        const boardElement = document.getElementById('board');
        const minesCountElement = document.getElementById('mines-count');
        const timerElement = document.getElementById('timer');
        const resetButton = document.getElementById('reset-button');
        const resultModal = document.getElementById('result-modal');
        const instructionsModal = document.getElementById('instructions-modal');
        
        function resetState(difficulty = 'medium') {
            if (state.timerInterval) clearInterval(state.timerInterval);
            const config = difficulties[difficulty];
            state = {
                rows: config.rows, cols: config.cols, mineCount: config.mines,
                board: [], revealedCount: 0, flaggedCount: 0,
                gameOver: false, firstClick: true, timerInterval: null, seconds: 0,
                difficulty, isFlagMode: false
            };
        }

        function init() {
            document.getElementById('newGameBtn').addEventListener('click', () => setDifficulty(state.difficulty));
            document.getElementById('instructionsBtn').addEventListener('click', () => instructionsModal.style.display = 'flex');
            document.getElementById('close-instructions-btn').addEventListener('click', () => instructionsModal.style.display = 'none');
            resetButton.addEventListener('click', () => setDifficulty(state.difficulty));
            resultModal.querySelector('button').addEventListener('click', () => { resultModal.style.display = 'none'; setDifficulty(state.difficulty); });

            ['easy', 'medium', 'hard'].forEach(diff => {
                document.getElementById(`${diff}Btn`).addEventListener('click', () => setDifficulty(diff));
            });

            document.getElementById('flagToggleBtn').addEventListener('click', toggleFlagMode);
            setDifficulty('medium');
        }

        function setDifficulty(difficulty) {
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${difficulty}Btn`).classList.add('active');
            resetState(difficulty);
            setupBoard();
        }

        function toggleFlagMode() {
            state.isFlagMode = !state.isFlagMode;
            const btn = document.getElementById('flagToggleBtn');
            btn.classList.toggle('active', state.isFlagMode);
            btn.textContent = state.isFlagMode ? 'ðŸš© Flag On' : 'ðŸš© Flag Off';
        }

        function setupBoard() {
            state.board = Array(state.rows).fill().map(() => Array(state.cols).fill(0));
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${state.cols}, var(--cell-size))`;
            
            for (let r = 0; r < state.rows; r++) {
                for (let c = 0; c < state.cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('mousedown', handleMouseDown);
                    cell.addEventListener('mouseup', handleMouseUp);
                    cell.addEventListener('mouseleave', handleMouseUp);
                    cell.addEventListener('contextmenu', handleRightClick);
                    boardElement.appendChild(cell);
                }
            }
            updateMinesCount();
            timerElement.textContent = '000';
            resetButton.textContent = 'ðŸ˜Š';
        }

        function placeMines(startR, startC) {
            let minesPlaced = 0;
            while (minesPlaced < state.mineCount) {
                const r = Math.floor(Math.random() * state.rows);
                const c = Math.floor(Math.random() * state.cols);
                if (state.board[r][c] !== 'M' && !(Math.abs(r - startR) <= 1 && Math.abs(c - startC) <= 1)) {
                    state.board[r][c] = 'M';
                    minesPlaced++;
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = r + dr; const nc = c + dc;
                            if (nr >= 0 && nr < state.rows && nc >= 0 && nc < state.cols && state.board[nr][nc] !== 'M') {
                                state.board[nr][nc]++;
                            }
                        }
                    }
                }
            }
        }

        function handleMouseDown(event) {
            if (state.gameOver) return;
            resetButton.textContent = 'ðŸ˜®';
            if (event.button === 0 && event.target.classList.contains('revealed')) {
                chord(event);
            }
        }

        function handleMouseUp(event) {
            if (state.gameOver) return;
            resetButton.textContent = 'ðŸ˜Š';
             if (event.type === 'mouseup' && event.button === 0) {
                handleCellClick(event);
            }
        }

        function handleCellClick(event) {
            if (event.target.classList.contains('revealed')) return;
            const r = parseInt(event.target.dataset.row);
            const c = parseInt(event.target.dataset.col);
            if (state.isFlagMode) { toggleFlag(r, c); return; }
            if (event.target.textContent === 'ðŸš©') return;
            
            if (state.firstClick) {
                placeMines(r, c);
                state.firstClick = false;
                startTimer();
            }
            if (state.board[r][c] === 'M') { endGame(false); return; }
            
            reveal(r, c);
        }

        function handleRightClick(event) {
            event.preventDefault();
            if (state.gameOver) return;
            const cell = event.target;
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
            if (cell.classList.contains('revealed')) return;
            toggleFlag(r, c);
        }

        function toggleFlag(r, c) {
            const cell = boardElement.children[r * state.cols + c];
            if (cell.textContent === 'ðŸš©') {
                cell.textContent = ''; state.flaggedCount--;
            } else if (state.flaggedCount < state.mineCount) {
                cell.textContent = 'ðŸš©'; state.flaggedCount++;
            }
            updateMinesCount();
        }
        
        function reveal(r, c) {
            const queue = [[r, c]];
            const visited = new Set([`${r},${c}`]);
            
            while(queue.length > 0) {
                const [curR, curC] = queue.shift();
                
                const cell = boardElement.children[curR * state.cols + curC];
                if (cell.classList.contains('revealed') || cell.textContent === 'ðŸš©') continue;

                cell.classList.add('revealed');
                state.revealedCount++;
                const value = state.board[curR][curC];
                
                if (value > 0) {
                    cell.textContent = value;
                    cell.classList.add(`cell-${value}`);
                } else if (value === 0) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = curR + dr;
                            const nc = curC + dc;
                            if (nr >= 0 && nr < state.rows && nc >= 0 && nc < state.cols && !visited.has(`${nr},${nc}`)) {
                                queue.push([nr, nc]);
                                visited.add(`${nr},${nc}`);
                            }
                        }
                    }
                }
            }
            checkWin(); // Check win only after a full reveal action is completed.
        }
        
        function chord(event) {
            const r = parseInt(event.target.dataset.row);
            const c = parseInt(event.target.dataset.col);
            const value = state.board[r][c];
            if (value > 0) {
                let adjacentFlags = 0;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = r + dr; const nc = c + dc;
                        if (nr >= 0 && nr < state.rows && nc >= 0 && nc < state.cols) {
                            if (boardElement.children[nr * state.cols + nc].textContent === 'ðŸš©') adjacentFlags++;
                        }
                    }
                }
                if (adjacentFlags === value) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = r + dr; const nc = c + dc;
                            if (nr >= 0 && nr < state.rows && nc >= 0 && nc < state.cols) {
                               const neighborCell = boardElement.children[nr * state.cols + nc];
                               if(!neighborCell.classList.contains('revealed') && neighborCell.textContent !== 'ðŸš©') {
                                   reveal(nr, nc);
                               }
                            }
                        }
                    }
                }
            }
        }


        function checkWin() {
            if (!state.gameOver && state.revealedCount === state.rows * state.cols - state.mineCount) {
                endGame(true);
            }
        }

        function endGame(isWin) {
            state.gameOver = true;
            clearInterval(state.timerInterval);
            
            const title = resultModal.querySelector('#result-title');
            const message = resultModal.querySelector('#result-message');
            
            if (isWin) {
                resetButton.textContent = 'ðŸ˜Ž';
                title.textContent = 'You Win! ðŸŽ‰';
                message.textContent = `Cleared in ${state.seconds} seconds!`;
            } else {
                resetButton.textContent = 'ðŸ˜µ';
                title.textContent = 'Game Over! ðŸ’£';
                message.textContent = 'You hit a mine!';
                let delay = 0;
                state.board.forEach((row, r) => {
                    row.forEach((val, c) => {
                        if (val === 'M') {
                            setTimeout(() => {
                                const cell = boardElement.children[r * state.cols + c];
                                if(cell && cell.textContent !== 'ðŸš©') {
                                    cell.classList.add('revealed', 'mine');
                                    cell.textContent = 'ðŸ’£';
                                }
                            }, delay++ * 15);
                        }
                    });
                });
            }
            setTimeout(() => resultModal.style.display = 'flex', isWin ? 500 : 1000);
        }

        function startTimer() {
            if(state.timerInterval) clearInterval(state.timerInterval);
            const startTime = Date.now();
            state.timerInterval = setInterval(() => {
                state.seconds = Math.floor((Date.now() - startTime) / 1000);
                timerElement.textContent = String(state.seconds).padStart(3, '0');
            }, 1000);
        }
        
        function updateMinesCount() {
            const remaining = state.mineCount - state.flaggedCount;
            minesCountElement.textContent = String(remaining).padStart(3, '0');
        }

        window.onload = init;
    </script>
</body>
</html>